<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>uuu6</title>
        <meta http-equiv="Permissions-Policy" content="geolocation=(self 'https://trusted-site.example')">
        <style>
            canvas {
                width: 100%;
                height: 100%;
                display: block;
            }
            body { 
                margin: 0; 
            }
        </style>
        <script src="https://apis.google.com/js/api.js"></script>
    </head>
    <body>
        <div id="info" style="position: absolute; top: 10px; left: 10px;"></div>
        <script type="module">
            import * as THREE from 'https://unpkg.com/three/build/three.module.js';

            class CameraControl {
                zoomMode = false;
                press = false;
                sensitivity = 0.01;

                constructor(renderer, camera, updateCallback) {
                    renderer.domElement.addEventListener('mousemove', event => {
                        if (!this.press) { return; }

                        if (event.button == 0) {
                            camera.position.y -= event.movementY * this.sensitivity;
                            camera.position.x -= event.movementX * this.sensitivity;
                        } else if (event.button == 2) {
                            camera.quaternion.y -= event.movementX * this.sensitivity / 10;
                            camera.quaternion.x -= event.movementY * this.sensitivity / 10;
                        }

                        updateCallback();
                    });


                    renderer.domElement.addEventListener('mousedown', () => { this.press = true; });
                    renderer.domElement.addEventListener('mouseup', () => { this.press = false; });
                    renderer.domElement.addEventListener('mouseleave', () => { this.press = false; });

                    document.addEventListener('keydown', event => {
                        if (event.key == 'Shift') {
                            this.zoomMode = true;
                        }
                    });

                    document.addEventListener('keyup', event => {
                        if (event.key == 'Shift') {
                            this.zoomMode = false;
                        }
                    });

                    renderer.domElement.addEventListener('mousewheel', event => {
                        if (this.zoomMode) {
                            camera.fov += event.wheelDelta * this.sensitivity;
                            camera.updateProjectionMatrix();
                        } else {
                            camera.position.z += event.wheelDelta * this.sensitivity;
                        }

                        updateCallback();
                    });
                }
            }

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            scene.background = new THREE.Color(0xdeebed);

            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Add point light
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            const sheetId = '1JHX3ghJYFD2DbbZI0Af5H1Urd1lg238j6lWbK23EFMc';
const sheetRange = 'Sheet1!A2:K';
const apiKey = '<your-api-key>';
let rows = [];
let spheres = [];

function createInfoDiv(sphere) {
  const infoDiv = document.createElement('div');
  infoDiv.style.cssText = `
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 10px;
    border-radius: 10px;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
    z-index: 100;
    max-width: 300px;
    max-height: 400px;
    overflow: auto;
  `;

  infoDiv.style.display = "none";

  const coords = document.createElement('p');
  const inverseCoords = document.createElement('p');
  const url = document.createElement('p');
  const title = document.createElement('p');
  const keywords = document.createElement('p');
  const actionWords = document.createElement('p');
  const summary = document.createElement('p');
  const image = document.createElement('img');

  infoDiv.appendChild(coords);
  infoDiv.appendChild(inverseCoords);
  infoDiv.appendChild(url);
  infoDiv.appendChild(title);
  infoDiv.appendChild(keywords);
	infoDiv.appendChild(actionWords);
  infoDiv.appendChild(summary);
  infoDiv.appendChild(image);
	
	document.body.appendChild(infoDiv);

  const canvas = document.querySelector('canvas');
	
	function handleSphereClick(event) {
  event.preventDefault();
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(scene.children);
  if (intersects.length > 0) {
    const selectedSphere = intersects[0].object;
    if (selectedSphere.userData) {
      coords.textContent = `(${selectedSphere.userData.coords.x}, ${selectedSphere.userData.coords.y}, ${selectedSphere.userData.coords.z})`;
      inverseCoords.textContent = `Inverse: [${selectedSphere.userData.inverseCoords.x},${selectedSphere.userData.inverseCoords.y},${selectedSphere.userData.inverseCoords.z}]`;
      url.textContent = `${selectedSphere.userData.url}`;
      url.style.wordWrap = "break-word";
      title.textContent = `Title: ${selectedSphere.userData.title}`;
      keywords.textContent = `Keywords: ${selectedSphere.userData.keywords}`;
      actionWords.textContent = `Action Words: ${selectedSphere.userData.actionWords}`;
      summary.textContent = `Summary: ${selectedSphere.userData.summary}`;
      summary.style.overflowWrap = "break-word";
      image.src = selectedSphere.userData.imageUrl;
      image.alt = `Sphere Image`;
      image.width = 150;
      image.height = 150;
      infoDiv.appendChild(image);
      infoDiv.style.display = "block";
    }
  }
function createSpheres(coordsList) {
  const spheres = [];
  for (let i = 0; i < coordsList.length; i++) {
    const [x, y, z] = coordsList[i];
    const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.5, 32, 32), new THREE.MeshPhongMaterial({ color: 0xff0000 }));
    sphere.position.set(x, y, z);
    spheres.push(sphere);
  }
  return spheres;
}

const coordsList = [  [0, 0, 0],
  [1, 1, 1],
  [-1, -1, -1]
];

const spheres = createSpheres(coordsList);
spheres.forEach(sphere => {
  scene.add(sphere);
});

	  fetch(`https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${sheetRange}?key=${apiKey}`)
  .then(response => response.json())
  .then(data => {
    const [headerRow, ...rowData] = data.values;
    rows = rowData;

    const coordsList = rows.map(row => [Number(row[1]), Number(row[2]), Number(row[3])]);
    const spheres = createSpheres(coordsList);
    sphere = rows.map((row, i) => {
      spheres[i].userData = {
        coords: { x: Number(row[1]), y: Number(row[2]), z: Number(row[3]) },
        inverseCoords: {},
        url: row[6],
        title: row[4],
        summary: row[5],
        keywords: row[7],
        actionWords: row[8],
        imageUrl: row[9],
      };
      spheres[i].position.set(...coordsList[i]);
      scene.add(spheres[i]);
      return spheres[i];
    });

    const infoDiv = createInfoDiv(sphere[0]);
    document.body.appendChild(infoDiv);

    for (let i = 0; i < sphere.length; i++) {
      const { x, y, z } = sphere[i].userData.coords;
      const inverseX = -1 * x;
      const inverseY = -1 * y;
      const inverseZ = -1 * z;
      sphere[i].userData.inverseCoords = { x: inverseX, y: inverseY, z: inverseZ };
    }
  })
  .catch(error => {
    console.error(error);
  });

	  const sphereMesh = new THREE.Mesh(
  new THREE.SphereGeometry(0.5, 32, 32),
  new THREE.MeshPhongMaterial({ color: 0xff0000 })
);
sphereMesh.position.set(-1, 0, 0);
scene.add(sphereMesh);

const cubeMesh = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshPhongMaterial({ color: 0x00ff00 })
);
cubeMesh.position.set(1, 0, 0);
scene.add(cubeMesh);

const coneMesh = new THREE.Mesh(
  new THREE.ConeGeometry(0.5, 1, 32),
  new THREE.MeshPhongMaterial({ color: 0x0000ff })
);
coneMesh.position.set(0, 1, 0);
scene.add(coneMesh);

const cylinderMesh = new THREE.Mesh(
  new THREE.CylinderGeometry(0.5, 0.5, 1, 32),
  new THREE.MeshPhongMaterial({ color: 0xffff00 })
);
cylinderMesh.position.set(0, -1, 0);
scene.add(cylinderMesh);

	  const spherePromises = rows.map(row => {
  const [id, x, y, z, title, summary, url, imageUrl, keywords, actionWords] = row;
  const coords = { x: Number(x), y: Number(y), z: Number(z) };
  const inverseCoords = { x: -coords.x, y: -coords.y, z: -coords.z };
  const userData = {
    coords: coords,
    inverseCoords: inverseCoords,
    url: url,
    title: title,
    summary: summary,
    keywords: keywords,
    actionWords: actionWords,
    imageUrl: imageUrl,
  };
  return new Promise((resolve, reject) => {
    const loader = new THREE.TextureLoader();
    loader.load(imageUrl, texture => {
      const sphere = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 32, 32),
        new THREE.MeshPhongMaterial({ map: texture })
      );
      sphere.position.set(coords.x, coords.y, coords.z);
      sphere.userData = userData;
      scene.add(sphere);
      resolve(sphere.userData);
    }, undefined, reject);
  });
});

Promise.all(spherePromises)
  .then(spheres => {
    const infoDiv = createInfoDiv(spheres[0]);
    document.body.appendChild(infoDiv);
    for (let i = 0; i < spheres.length; i++) {
      const { x, y, z } = spheres[i].coords;
      const inverseX = -1 * x;
      const inverseY = -1 * y;
      const inverseZ = -1 * z;
      spheres[i].inverseCoords = { x: inverseX, y: inverseY, z: inverseZ };
    }
  })
  .catch(error => {
    console.error(error);
  });

	    const sheetId = '1JHX3ghJYFD2DbbZI0Af5H1Urd1lg238j6lWbK23EFMc';
  const sheetRange = 'Sheet1!A2:K';
  const apiKey = 'AIzaSyB4WCgKCsz13xzw13Ln2kP1ZWuBWQYTj24';
  let rows = [];

  fetch(`https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${sheetRange}?key=${apiKey}`)
    .then(response => response.json())
    .then(data => {
      const [headerRow, ...rowData] = data.values;
      rows = rowData;

      // Create spheres from the rows data
      const spheres = createSpheres(rows.map(row => [Number(row[1]), Number(row[2]), Number(row[3])]));

      // Add an event listener for clicking on any object in the scene
      document.addEventListener('click', (event) => {
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        // Calculate mouse position in normalized device coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // Cast a ray from the camera to the clicked point
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children);

        if (intersects.length > 0) {
          const selectedObject = intersects[0].object;
          const { x, y, z } = selectedObject.userData.coords;
          const { x: ix, y: iy, z: iz } = selectedObject.userData.inverseCoords;

          console.log(`Selected object coordinates: (${x}, ${y}, ${z})`);
          console.log(`Selected object inverse coordinates: (${ix}, ${iy}, ${iz})`);
          console.log(`Selected object URL: ${selectedObject.userData.url}`);
          console.log(`Selected object title: ${selectedObject.userData.title}`);
          console.log(`Selected object summary: ${selectedObject.userData.summary}`);
          console.log(`Selected object image URL: ${selectedObject.userData.imageUrl}`);
        }
      });
    })
    .catch(error => {
      console.error(error);
    });
	  
	      // Add an event listener for clicking on any object in the scene
    document.addEventListener('click', (event) => {
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      // Calculate mouse position in normalized device coordinates
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Cast a ray from the camera to the clicked point
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children);

      if (intersects.length > 0) {
        const selectedObject = intersects[0].object;
        const { x, y, z } = selectedObject.userData.coords;
        const { x: ix, y: iy, z: iz } = selectedObject.userData.inverseCoords;

        console.log(`Selected object coordinates: (${x}, ${y}, ${z})`);
        console.log(`Selected object inverse coordinates: (${ix}, ${iy}, ${iz})`);
        console.log(`Selected object URL: ${selectedObject.userData.url}`);
        console.log(`Selected object title: ${selectedObject.userData.title}`);
        console.log(`Selected object summary: ${selectedObject.userData.summary}`);
        console.log(`Selected object image URL: ${selectedObject.userData.imageUrl}`);
      }
    });

    camera.position.z = 5;

    const cameraControl = new CameraControl(renderer, camera, () => {
      renderer.render(scene, camera);
    });

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    animate();
	</body>
</html>
