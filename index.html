<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>3Inteliflow app</title>
	<meta http-equiv="Permissions-Policy" content="geolocation=(self 'https://trusted-site.example')">
        <style>
		canvas {
    width: 100%;
    height: 100%;
    display: block;
}
		body { margin: 0; }
        </style>
	    <script src="https://apis.google.com/js/api.js"></script>
    </head>
    <body>
         <div id="info" style="position: absolute; top: 10px; left: 10px;">
      <div id="coords"></div>
      <div id="inverseCoords"></div>
      <div id="url"></div>
      <div id="title"></div>
      <div id="keywords"></div>
      <div id="actionWords"></div>
      <div id="summary"></div>
      <img id="image" />
    </div>

        <script type="module">
            import * as THREE from 'https://unpkg.com/three/build/three.module.js';

            class CameraControl {
			    zoomMode = false;
			    press = false;
			    sensitivity = 0.01;

			    constructor(renderer, camera, updateCallback) {
			        renderer.domElement.addEventListener('mousemove', event => {
			            if (!this.press) { return; }

			            if (event.button == 0) {
			                camera.position.y -= event.movementY * this.sensitivity;
			                camera.position.x -= event.movementX * this.sensitivity;
			            } else if (event.button == 2) {
			                camera.quaternion.y -= event.movementX * this.sensitivity / 10;
			                camera.quaternion.x -= event.movementY * this.sensitivity / 10;
			            }

			            updateCallback();
			        });


                    renderer.domElement.addEventListener('mousedown', () => { this.press = true; });
                    renderer.domElement.addEventListener('mouseup', () => { this.press = false; });
                    renderer.domElement.addEventListener('mouseleave', () => { this.press = false; });

                    document.addEventListener('keydown', event => {
                        if (event.key == 'Shift') {
                            this.zoomMode = true;
                        }
                    });

                    document.addEventListener('keyup', event => {
                        if (event.key == 'Shift') {
                            this.zoomMode = false;
                        }
                    });

                    renderer.domElement.addEventListener('mousewheel', event => {
                        if (this.zoomMode) {
                            camera.fov += event.wheelDelta * this.sensitivity;
                            camera.updateProjectionMatrix();
                        } else {
                            camera.position.z += event.wheelDelta * this.sensitivity;
                        }

                        updateCallback();
                    });
                }
            }

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            scene.background = new THREE.Color(0xdeebed);

            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Add point light
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
		
		function setInfoDivData(clickedObject) {
  // Find the Mesh with userData by checking the clicked object and its ancestors
  let mesh;
  let object = clickedObject;
  while (object && !mesh) {
    if (object.type === 'Mesh' && object.userData) {
      mesh = object;
    } else {
      object = object.parent;
    }
  }

  if (mesh) {
    const coords = document.getElementById('coords');
    const inverseCoords = document.getElementById('inverseCoords');
    const url = document.getElementById('url');
    const title = document.getElementById('title');
    const keywords = document.getElementById('keywords');
    const actionWords = document.getElementById('actionWords');
    const summary = document.getElementById('summary');
    

coords.innerHTML = `<strong>[${mesh.position.x.toFixed(2)}, ${mesh.position.y.toFixed(2)}, ${mesh.position.z.toFixed(2)}]</strong>`;
inverseCoords.innerHTML = `<strong>Inverse:</strong> [${mesh.userData.inverseCoords.x}, ${mesh.userData.inverseCoords.y}, ${mesh.userData.inverseCoords.z}]`;
url.innerHTML = `<a href="${mesh.userData.url}" target="_blank">${mesh.userData.url}</a>`;
title.innerHTML = `<strong>Title:</strong> ${mesh.userData.title}`;
keywords.innerHTML = `<strong>Keywords:</strong> ${mesh.userData.keywords}`;
actionWords.innerHTML = `<strong>Action Words:</strong> ${mesh.userData.actionWords}`;
summary.innerHTML = `<strong>Summary:</strong> ${mesh.userData.summary}`;


    // Set the style for the infoDiv element
    const infoDiv = document.getElementById('info');
    infoDiv.style.position = 'absolute';
    infoDiv.style.top = '10px';
    infoDiv.style.right = '100px';
    infoDiv.style.maxWidth = '300px';
    infoDiv.style.maxHeight = '550px';
    infoDiv.style.overflow = 'auto';
    infoDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
    infoDiv.style.padding = '10px';
    infoDiv.style.borderRadius = '10px';
    infoDiv.style.boxShadow = '2px 2px 5px rgba(0, 0, 0, 0.3)';
    infoDiv.style.zIndex = '100';
    infoDiv.style.display = 'block';
	  
  }
}





const sheetId = '1JHX3ghJYFD2DbbZI0Af5H1Urd1lg238j6lWbK23EFMc';
const sheetRange = 'Sheet1!A2:K';
const apiKey = 'AIzaSyB4WCgKCsz13xzw13Ln2kP1ZWuBWQYTj24';

fetch(`https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${sheetRange}?key=${apiKey}`)
  .then(response => response.json())
  .then(data => {
    data.values.forEach(row => {
      const coords = row[8].split(',').map((coord) => parseFloat(coord));
      console.log('coords:', coords);
      const inverseCoords = new THREE.Vector3(-coords[0], -coords[1], -coords[2]);

      // Create the sphere
      const geometry = new THREE.SphereGeometry(0.5, 32, 32);
      const material = new THREE.MeshPhongMaterial({ color: 0xffffff });
      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.set(...coords);
      sphere.userData = {
        coords: coords,
        inverseCoords: inverseCoords,
        url: row[0],
        title: row[1],
        summary: row[4],
        keywords: row[5],
        actionWords: row[6],
        imageUrl: row[10],
      };
      scene.add(sphere);
    });
  })
  .catch(error => {
    console.error('Error fetching data:', error);
  });
		
// Add an event listener for clicking on any object in the scene
document.addEventListener('click', (event) => {
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  
  // Calculate mouse position in normalized device coordinates
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // Cast a ray from the camera to the clicked point
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(scene.children);

  if (intersects.length > 0) {
    const selectedObject = intersects[0].object;

    setInfoDivData(selectedObject);
  }
});
		
document.addEventListener('click', (event) => {
  const infoDiv = document.getElementById('info');
  if (infoDiv.style.display === 'block') {
    const clickedElement = event.target;
    if (!clickedElement.closest('#info')) {
      infoDiv.style.display = 'none';
    }
  }
});


camera.position.set(0, 0, 20)
		const cameraControl = new CameraControl(renderer, camera, () => {
renderer.render(scene, camera);
});

function animate() {
requestAnimationFrame(animate);
renderer.render(scene, camera);
}

animate();
		</script>
	</body>
</html>

